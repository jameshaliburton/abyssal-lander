<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Abyssal Lander - Disruptor Edition</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000;
            overflow: hidden;
            color: #00ffff; /* Command Line Blue (Cyan) */
            font-family: 'Courier New', Courier, monospace;
            touch-action: none;
            user-select: none;
            -webkit-user-select: none;
        }
        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            cursor: crosshair;
            background-color: #00050a; /* Very dark blue tint */
        }
        #ui-layer {
            position: absolute;
            top: 60px; 
            left: 20px;
            pointer-events: none;
            text-shadow: 0 0 5px #00ffff;
            z-index: 5;
        }
        .hud-line {
            margin-bottom: 5px;
            font-size: 14px;
            letter-spacing: 1px;
            font-weight: bold;
        }
        .warning {
            color: red;
            text-shadow: 0 0 5px red;
            animation: blinker 0.2s linear infinite;
        }
        #message-overlay {
            position: absolute;
            top: 40%; 
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            display: none;
            z-index: 10;
            width: 80%;
            pointer-events: none;
        }
        h1 {
            font-size: 32px;
            margin: 0 0 20px 0;
            text-transform: uppercase;
            border: 2px solid #00ffff;
            padding: 10px 10px;
            background: rgba(0, 20, 30, 0.9);
            box-shadow: 0 0 15px #00ffff;
        }
        p {
            font-size: 16px;
            margin-bottom: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 10px;
        }
        .blink {
            animation: blinker 1s linear infinite;
        }
        @keyframes blinker {
            50% { opacity: 0; }
        }
        #bar-container {
            width: 150px;
            height: 10px;
            border: 1px solid #00ffff;
            margin-top: 5px;
            position: relative;
        }
        #stress-bar {
            height: 100%;
            width: 0%;
            background-color: #00ffff;
            transition: width 0.1s;
            box-shadow: 0 0 5px #00ffff;
        }

        /* --- MOBILE CONTROLS --- */
        #mobile-controls {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 180px;
            background: #001122;
            border-top: 2px solid #00ffff;
            display: none;
            flex-direction: row;
            justify-content: space-between;
            align-items: center;
            padding: 10px 20px;
            box-sizing: border-box;
            z-index: 100;
        }

        body.is-mobile #mobile-controls { display: flex; }
        body.is-mobile #ui-layer { font-size: 12px; top: 10px; left: 10px; }
        body.is-mobile .hud-line { font-size: 12px; }
        body.is-mobile canvas { cursor: default; }

        .control-group {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .d-pad-col {
            display: flex;
            flex-direction: column;
            gap: 10px;
            align-items: center;
        }

        .btn {
            width: 70px;
            height: 70px;
            border: 2px solid #00ffff;
            background: rgba(0, 40, 50, 0.3);
            border-radius: 12px;
            color: #00ffff;
            font-size: 30px;
            display: flex;
            justify-content: center;
            align-items: center;
            user-select: none;
            -webkit-user-select: none;
            transition: background 0.1s;
        }

        .btn:active, .btn.active {
            background: #00ffff;
            color: #000;
            box-shadow: 0 0 15px #00ffff;
        }

        .btn-wide {
            width: 100px;
            height: 60px;
            font-size: 16px;
            font-weight: bold;
            font-family: 'Courier New', monospace;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="hud-line">LEVEL: <span id="level-val">1</span></div>
        <div class="hud-line">DEPTH: <span id="depth-val">0</span>m</div>
        <div class="hud-line">NEAREST LZ: <span id="target-depth-val">--</span>m</div>
        <div class="hud-line">V.SPEED: <span id="vspeed-val">0</span> m/s</div>
        <div class="hud-line">H.SPEED: <span id="hspeed-val">0</span> m/s</div>
        <div class="hud-line">BATTERY: <span id="fuel-val">100</span>%</div>
        <div class="hud-line" id="hull-row">HULL: <span id="hull-val">100</span>%</div>
        
        <div class="hud-line" style="margin-top: 15px;">EXT. PRESSURE:</div>
        <div id="bar-container">
            <div id="stress-bar"></div>
        </div>
        <div class="hud-line" id="stress-text" style="font-size: 12px; margin-top: 2px;">STABLE</div>

        <div class="hud-line" style="margin-top: 15px;">SCORE: <span id="score-val">0</span></div>
    </div>

    <div id="message-overlay">
        <h1 id="msg-title">ABYSSAL LANDER</h1>
        <p id="msg-desc">
            <span style="color:#00ffff">SYSTEM INITIALIZED</span><br>
            Current Depth: Shallow<br>
            Goal: Land to advance deeper.<br>
            Note: Pressure increases with depth.
        </p>
        <p class="blink">PRESS SPACE OR CLICK TO DIVE</p>
    </div>

    <div id="mobile-controls">
        <div class="control-group">
            <div class="btn" id="btn-left">&lt;</div>
            <div class="btn" id="btn-right">&gt;</div>
        </div>
        <div class="btn btn-wide" id="btn-space">INIT</div>
        <div class="d-pad-col">
            <div class="btn" id="btn-up">^</div>
            <div class="btn" id="btn-down">v</div>
        </div>
    </div>

    <canvas id="gameCanvas"></canvas>

<script>
/**
 * ABYSSAL LANDER - SIMULATION EDITION
 */

console.log("[ABYSSAL] Init Script Started");

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
const mobileControls = document.getElementById('mobile-controls');

// Color Palette
const C_BLUE = '#00ffff';
const C_WHITE = '#ffffff';
const C_RED = '#ff3333';
const C_WARN = '#ffaa00';

// UI Elements
const uiElements = document.getElementById('ui-layer');
const uiLevel = document.getElementById('level-val');
const uiDepth = document.getElementById('depth-val');
const uiTargetDepth = document.getElementById('target-depth-val');
const uiVSpeed = document.getElementById('vspeed-val');
const uiHSpeed = document.getElementById('hspeed-val');
const uiFuel = document.getElementById('fuel-val');
const uiHull = document.getElementById('hull-val');
const uiHullRow = document.getElementById('hull-row');
const uiScore = document.getElementById('score-val');
const uiStressBar = document.getElementById('stress-bar');
const uiStressText = document.getElementById('stress-text');
const msgOverlay = document.getElementById('message-overlay');
const msgTitle = document.getElementById('msg-title');
const msgDesc = document.getElementById('msg-desc');

// Game State Enum
const STATE = { INTRO: 0, TITLE: 1, PLAYING: 2, LANDED: 3, CRASHED: 4, IMPLODED: 5 };

let gameState = STATE.INTRO;
let width = 800, height = 600;
let lastTime = 0;
let timeAccumulator = 0; 
let score = 0;
let shakeAmount = 0;
let level = 1;
let currentNearestDepth = 0;
let frameCount = 0;

// Intro Vars
let introScrollY = 0;
const introLines = [
    "THE YEAR IS 2023.",
    "",
    "TRADITIONAL SUBMERSIBLES ARE OBSOLETE.",
    "SAFETY REGULATIONS STIFLE INNOVATION.",
    "CERTIFICATION IS A MYTH.",
    "",
    "YOU ARE A VISIONARY BILLIONAIRE.",
    "YOU BUILT A REVOLUTIONARY HULL.",
    "AEROSPACE-GRADE CARBON FIBER.",
    "UNTESTED. UNCLASSED. UNSTOPPABLE.",
    "",
    "ENGINEERS SAID THE PHYSICS DONT WORK.",
    "CRITICS WARNED OF DELAMINATION.",
    "YOU FIRED THEM ALL.",
    "",
    "YOU HAVE A LOGITECH GAMEPAD.",
    "YOU HAVE DISRUPTIVE AMBITION.",
    "",
    "GUIDE YOUR EXPERIMENTAL VESSEL",
    "TO THE TITANIC DEPTHS.",
    "",
    "IGNORE THE CRACKING SOUNDS.",
    "PHYSICS IS JUST A SUGGESTION."
];
// Inputs
const keys = { 
    ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false, Space: false,
    KeyW: false, KeyS: false, KeyA: false, KeyD: false, Enter: false
};

// --- PHYSICS CONSTANTS ---
// TUNED: Heavyweight Edition (Smoother inputs, deadlier gravity)
const GRAVITY = 7.0;  // Increased from 5.5 (Falls much faster)
const WATER_DRAG = 0.975; // Less drag, preserving downward momentum
const V_THRUST_POWER = 45; // Reduced from 65 (Less twitchy, requires planning)
const H_THRUST_POWER = 25; 
let currentSafeLandingSpeed = 20; // Changed from const to let for dynamic scaling
const MAX_TILT = 0.12; 
const MAX_STRESS = 100; 
let CURRENT_DEPTH_PRESSURE_MAX = 60; 
const VELOCITY_STRESS_FACTOR = 32.0; // Increased from 22.0 (Speed is lethal)

// Game Objects
let sub = {
    x: 0, y: 0, vx: 0, vy: 0,
    angle: 0, tilt: 0, fuel: 100, hull: 100, stress: 0,
    width: 30, height: 14 // Width reduced slightly (34->30) to reduce wall clipping
};

let terrain = [];
let particles = [];
let bubbles = [];
let marineSnow = []; 

// --- MOBILE DETECTION ---
function isMobileDevice() {
    const ua = navigator.userAgent;
    return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini|Mobile|mobile/i.test(ua);
}

// --- RESIZE & LAYOUT ---
function resize() {
    if (isMobileDevice()) {
        document.body.classList.add('is-mobile');
    } else {
        document.body.classList.remove('is-mobile');
    }

    let controlsHeight = 0;
    const style = window.getComputedStyle(mobileControls);
    if (style.display !== 'none') {
        controlsHeight = mobileControls.offsetHeight;
    }

    width = Math.floor(window.innerWidth);
    height = Math.floor(window.innerHeight - controlsHeight);
    
    // Safety Fallbacks - Updated for Mobile Landscape
    if (width < 320) width = 320;
    // Lowered minimum height to prevent clipping on landscape phones
    if (height < 150) height = 150; 

    canvas.width = width;
    canvas.height = height;
    
    // Reset intro scroll if needed
    if (gameState === STATE.INTRO && introScrollY === 0) {
        introScrollY = height + 50;
    }
    
    initMarineSnow();
    draw();
}

window.addEventListener('resize', resize);
window.addEventListener('load', () => {
    resize();
    window.focus(); // Force focus on load
});
setTimeout(resize, 100);

// --- INPUT HANDLING ---

// Force focus on click to ensure keyboard events are captured
window.addEventListener('click', () => {
    window.focus();
});

window.addEventListener('keydown', (e) => {
    // Prevent default scrolling for game keys
    if (["Space", "ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"].indexOf(e.code) > -1) {
        e.preventDefault();
    }

    if (e.code === 'Space' || e.code === 'Enter') {
        handleAction();
    }
    
    if (keys.hasOwnProperty(e.code)) {
        keys[e.code] = true;
    }
});

window.addEventListener('keyup', (e) => {
    if (keys.hasOwnProperty(e.code)) keys[e.code] = false;
});

canvas.addEventListener('mousedown', (e) => {
    if (gameState !== STATE.PLAYING) handleAction();
});

function setupTouchButton(id, keyName) {
    const btn = document.getElementById(id);
    if(!btn) return;
    
    const start = (e) => {
        e.preventDefault(); e.stopPropagation();
        if (keyName === 'Space') handleAction();
        keys[keyName] = true;
        btn.classList.add('active');
    };
    const end = (e) => {
        e.preventDefault(); e.stopPropagation();
        keys[keyName] = false;
        btn.classList.remove('active');
    };
    
    btn.addEventListener('touchstart', start, {passive: false});
    btn.addEventListener('touchend', end, {passive: false});
    btn.addEventListener('mousedown', start);
    btn.addEventListener('mouseup', end);
    btn.addEventListener('mouseleave', end);
}

setupTouchButton('btn-left', 'ArrowLeft');
setupTouchButton('btn-right', 'ArrowRight');
setupTouchButton('btn-up', 'ArrowUp');
setupTouchButton('btn-down', 'ArrowDown');
setupTouchButton('btn-space', 'Space');

function handleAction() {
    if (gameState === STATE.INTRO) {
        // Skip intro
        gameState = STATE.TITLE;
    } else if (gameState === STATE.TITLE || gameState === STATE.CRASHED || gameState === STATE.IMPLODED) {
        if (gameState === STATE.CRASHED || gameState === STATE.IMPLODED) {
             level = 1;
             score = 0;
        }
        startGame();
    } else if (gameState === STATE.LANDED) {
        level++;
        startGame();
    }
}

// --- GENERATION ---

function initMarineSnow() {
    marineSnow = [];
    // Scale particle count by screen size
    let count = Math.floor((width * height) / 5000); 
    if (count > 150) count = 150;
    
    for(let i=0; i<count; i++) {
        marineSnow.push({
            x: Math.random() * width,
            y: Math.random() * height,
            size: Math.random() * 1.5,
            speed: 0.2 + Math.random() * 0.5
        });
    }
}

function generateTerrain() {
    terrain = [];
    if (!width || width < 100) resize();

    // 1. DYNAMIC DEPTH CAP
    let maxDepthPct = isMobileDevice() ? 0.75 : 0.85;
    let baseDepthPct = 0.3 + (Math.min(level, 5) * 0.12); 
    if (baseDepthPct > maxDepthPct) baseDepthPct = maxDepthPct;

    // 2. PRESSURE SCALING
    CURRENT_DEPTH_PRESSURE_MAX = 55 + (level * 4);
    if (CURRENT_DEPTH_PRESSURE_MAX > 98) CURRENT_DEPTH_PRESSURE_MAX = 98;

    // 3. LANDING DIFFICULTY SCALING (New)
    // Level 1: 20 (Forgiving) -> Level 5+: 12 (Strict)
    currentSafeLandingSpeed = Math.max(12, 22 - (level * 2));

    // 4. DYNAMIC RESOLUTION
    const segments = Math.max(40, Math.min(150, Math.floor(width / 8)));
    const segmentWidth = width / segments;
    
    // 3. DYNAMIC ROUGHNESS
    // Roughness scales with height. 
    // Don't let spikes be taller than 15% of the screen height.
    let roughness = Math.min(60, height * 0.15);
    if (roughness < 15) roughness = 15; // Minimum jaggedness

    let currentY = height * baseDepthPct;
    
    terrain.push({x: 0, y: height * (baseDepthPct - 0.1), type: 'jagged'}); 

    let makingPad = false;
    let padLength = 0;
    let padStartX = 0;
    let padStartY = 0;
    let padCount = 0;

    const minPadSegments = Math.ceil((sub.width * 1.5) / segmentWidth);
    let padChance = 0.04 - (level * 0.003); 
    if (padChance < 0.015) padChance = 0.015;

    for (let i = 0; i <= segments; i++) {
        let x = i * segmentWidth;
        let type = 'jagged';
        
        let forceSpawn = (padCount === 0 && i > (segments * 0.75));

        if (!makingPad && i > 5 && i < segments - 5 && (Math.random() < padChance || forceSpawn)) {
            makingPad = true;
            padLength = minPadSegments + Math.floor(Math.random() * 2); 
            padStartX = x;
            padStartY = currentY; 
            padCount++;
        }

        if (makingPad) {
            type = 'pad';
            currentY = padStartY; 
            padLength--;
            if (padLength <= 0) makingPad = false;
        } else {
            // Use dynamic roughness
            currentY += (Math.random() - 0.5) * roughness;
            
            // Safety Clamps relative to screen size
            if (currentY < height * 0.2) currentY = height * 0.2;
            if (currentY > height - 10) currentY = height - 10; // Keep 10px buffer from bottom
        }

        terrain.push({x: x, y: currentY, type: type});
    }
}

function resetSub() {
    sub.x = width / 2;
    sub.y = 80; 
    sub.vx = 0;
    sub.vy = 0;
    sub.tilt = 0;
    sub.fuel = 100;
    sub.hull = 100;
    sub.stress = 0;
    shakeAmount = 0;
}

function startGame() {
    resize();
    generateTerrain();
    resetSub();
    initMarineSnow();
    particles = [];
    bubbles = [];
    gameState = STATE.PLAYING;
    msgOverlay.style.display = 'none';
    uiElements.style.display = 'block';
}

// --- PHYSICS ENGINE ---

function update(dt) {
    if (isNaN(dt)) return; 
    timeAccumulator += dt;

    if (gameState === STATE.INTRO) {
        // Scroll text
        introScrollY -= 30 * dt; // Scroll speed
        // Check if finished
        let totalHeight = introLines.length * 40;
        if (introScrollY < -(totalHeight + 100)) {
            gameState = STATE.TITLE;
        }
        
        // Skip intro with controls
        if (keys.Space || keys.Enter) {
            gameState = STATE.TITLE;
            // Reset keys to prevent accidental start
            keys.Space = false;
            keys.Enter = false;
        }

        updateMarineSnow(dt, 0, 0); 
        return;
    }

    if (gameState === STATE.TITLE) {
        updateParticles(dt); 
        spawnBubbles('ambient');
        updateBubbles(dt);
        updateMarineSnow(dt, 0, 0); 
        return;
    }

    if (gameState !== STATE.PLAYING) {
        updateParticles(dt); 
        shakeAmount = Math.max(0, shakeAmount - 1);
        return;
    }

    // Controls (Arrows OR WASD)
    if (sub.fuel > 0) {
        if (keys.ArrowUp || keys.KeyW) {
            sub.vy -= V_THRUST_POWER * dt;
            sub.fuel -= 5 * dt; 
            spawnBubbles('vertical_down'); 
        }
        if (keys.ArrowDown || keys.KeyS) {
            sub.vy += V_THRUST_POWER * dt;
            sub.fuel -= 5 * dt;
            spawnBubbles('vertical_up'); 
        }
        if (keys.ArrowLeft || keys.KeyA) {
            sub.vx -= H_THRUST_POWER * dt;
            sub.fuel -= 5 * dt;
            spawnBubbles('right'); 
            sub.tilt = -MAX_TILT;
        } else if (keys.ArrowRight || keys.KeyD) {
            sub.vx += H_THRUST_POWER * dt;
            sub.fuel -= 5 * dt;
            spawnBubbles('left'); 
            sub.tilt = MAX_TILT;
        } else {
            sub.tilt = sub.tilt * 0.9;
        }
    }

    // High Inertia Movement
    sub.vy += GRAVITY * dt;
    sub.vx *= WATER_DRAG; 
    sub.vy *= WATER_DRAG; 
    
    sub.x += sub.vx * dt * 10; 
    sub.y += sub.vy * dt * 10;

    if (sub.x < 0) sub.x = width;
    if (sub.x > width) sub.x = 0;

    updateMarineSnow(dt, sub.vx, sub.vy);

    let screenDepthRatio = Math.max(0, (sub.y - 100) / (height - 100));
    let staticStress = screenDepthRatio * CURRENT_DEPTH_PRESSURE_MAX;
    
    let horizontalFactor = 0.2; 
    let weightedSpeed = Math.sqrt((sub.vx * horizontalFactor)**2 + sub.vy**2);
    let dynamicStress = weightedSpeed * VELOCITY_STRESS_FACTOR;
    
    // SMOOTHING: Target stress vs current stress
    // This removes the "jitter" from thrusters and makes pressure feel heavy
    let targetStress = staticStress + dynamicStress;
    sub.stress = sub.stress + (targetStress - sub.stress) * 0.05; // 5% blend per frame

    // --- DAMAGE LOGIC ---
    if (sub.stress > MAX_STRESS) {
        // CRITICAL (Red Zone): Massive Damage
        let overload = sub.stress - MAX_STRESS;
        sub.hull -= overload * dt * 10.0; 
        shakeAmount = Math.min(overload * 0.5, 10);
    } else if (sub.stress > 80) {
        // WARNING (Yellow Zone): Structural Fatigue
        // Hull slowly cracks if you sustain high pressure
        let overload = sub.stress - 80;
        sub.hull -= overload * dt * 0.8; // Slower damage, but adds up
        shakeAmount = Math.max(1, shakeAmount - 1); // Slight rattle to warn player
    } else {
        shakeAmount = Math.max(0, shakeAmount - 2);
    }

    if (sub.hull <= 0) {
        triggerImplosion("HULL FATIGUE FAILURE");
    }

    checkCollisions();
    updateUI();
    updateParticles(dt);
    updateBubbles(dt);
}

function updateMarineSnow(dt, subVx, subVy) {
    marineSnow.forEach(p => {
        p.y -= subVy * dt * 5; 
        p.x -= subVx * dt * 5;
        p.y -= p.speed * 20 * dt; 
        if (p.y > height) p.y = 0;
        if (p.y < 0) p.y = height;
        if (p.x > width) p.x = 0;
        if (p.x < 0) p.x = width;
    });
}

function checkCollisions() {
    const subPoly = getSubPolygon();
    
    // Find nearest pad for forgiveness check
    let nearestPadX = -1;
    let nearestPadY = -1;
    let minDist = Infinity;
    
    // Locate the closest pad center
    for (let i = 0; i < terrain.length - 1; i++) {
        if (terrain[i].type === 'pad' && terrain[i+1].type === 'pad') {
            let midX = (terrain[i].x + terrain[i+1].x) / 2;
            let d = Math.abs(sub.x - midX);
            if (d < minDist) {
                minDist = d;
                nearestPadX = midX;
                nearestPadY = terrain[i].y;
            }
        }
    }

    for (let i = 0; i < terrain.length - 1; i++) {
        let p1 = terrain[i];
        let p2 = terrain[i+1];
        
        // Optimization: Only check lines close to sub
        if (Math.abs(p1.x - sub.x) > 100 && Math.abs(p2.x - sub.x) > 100) continue;

        for (let j = 0; j < subPoly.length; j++) {
            let s1 = subPoly[j];
            let s2 = subPoly[(j + 1) % subPoly.length];
            if (lineIntersect(p1.x, p1.y, p2.x, p2.y, s1.x, s1.y, s2.x, s2.y)) {
                handleCollision(p1, p2, nearestPadX, nearestPadY);
                return;
            }
        }
    }
    if (sub.y > height) triggerImplosion("LOST TO THE ABYSS");
}

function handleCollision(t1, t2, padX, padY) {
    let vSpeed = Math.abs(sub.vy * 10);
    let hSpeed = Math.abs(sub.vx * 10);
    let isPad = t1.type === 'pad' && t2.type === 'pad';
    let isFlat = Math.abs(t1.y - t2.y) < 5;

    // FORGIVENESS LOGIC:
    let distToPad = Math.abs(sub.x - padX);
    let closeEnough = (padX !== -1) && (distToPad < 35); 
    
    // Check if speed/angle is safe for landing using DYNAMIC limit
    let isSafeLandingConfig = (vSpeed < currentSafeLandingSpeed && hSpeed < 5 && Math.abs(sub.tilt) < MAX_TILT);

    if ((isPad && isFlat) || (closeEnough && isSafeLandingConfig)) {
        if (isSafeLandingConfig) {
            gameWin();
        } else {
            if (hSpeed >= 5) {
                gameCrash("LATERAL MOVEMENT TOO FAST");
            } else if (Math.abs(sub.tilt) >= MAX_TILT) {
                gameCrash("BAD ANGLE");
            } else {
                gameCrash("IMPACT VELOCITY CRITICAL");
            }
        }
    } else {
        gameCrash("UNSAFE TERRAIN");
    }
}

function gameWin() {
    gameState = STATE.LANDED;
    let roundScore = Math.floor(sub.fuel * 10) + Math.floor(sub.hull * 10) + (currentNearestDepth * 5);
    score += roundScore;
    
    msgTitle.innerText = "DEPTH SECURED";
    msgTitle.style.borderColor = C_BLUE;
    msgDesc.innerHTML = `
        Depth: ${currentNearestDepth}m<br>
        Pressure Rating: ${Math.floor(CURRENT_DEPTH_PRESSURE_MAX)}%<br>
        Round Score: ${roundScore}<br>
        <span style="color:#fff">PREPARING NEXT DIVE...</span>
    `;
    msgOverlay.style.display = 'block';
    
    const btn = document.getElementById('btn-space');
    if (btn) btn.innerText = "NEXT";
}

function gameCrash(reason) {
    gameState = STATE.CRASHED;
    msgTitle.innerText = "CRITICAL FAILURE";
    msgTitle.style.borderColor = "red";
    msgDesc.innerHTML = `${reason}<br>Submarine destroyed.<br>Final Score: ${score}`;
    msgOverlay.style.display = 'block';
    const btn = document.getElementById('btn-space');
    if (btn) btn.innerText = "RETRY";
}

function triggerImplosion(reason) {
    gameState = STATE.IMPLODED;
    for (let i = 0; i < 250; i++) {
        let theta = Math.random() * Math.PI * 2;
        let r = 20 + Math.random() * 20; 
        let sx = sub.x + Math.cos(theta) * r;
        let sy = sub.y + Math.sin(theta) * r;
        particles.push({
            x: sx, y: sy, targetX: sub.x, targetY: sub.y,
            phase: 'implode', life: 0, angle: Math.random() * Math.PI * 2, len: 2 + Math.random() * 5
        });
    }
    msgTitle.innerText = "STRUCTURAL COLLAPSE";
    msgTitle.style.borderColor = "white";
    msgDesc.innerHTML = `${reason}<br>Implosion detected.<br>Final Score: ${score}`;
    msgOverlay.style.display = 'block';
    const btn = document.getElementById('btn-space');
    if (btn) btn.innerText = "RETRY";
}

// --- RENDER ---
function draw() {
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    if (canvas.width <= 0 || canvas.height <= 0) return;

    ctx.fillStyle = '#000000';
    ctx.fillRect(0, 0, width, height);

    if (gameState === STATE.INTRO) { drawIntro(); return; }
    if (gameState === STATE.TITLE) { drawTitleScreen(); return; }

    ctx.save();
    if (shakeAmount > 0) {
        let sx = (Math.random() - 0.5) * shakeAmount;
        let sy = (Math.random() - 0.5) * shakeAmount;
        ctx.translate(sx, sy);
    }
    
    drawMarineSnow(); 
    drawWaves();
    drawTerrain(); 
    drawBubbles();
    drawParticles();
    
    if (gameState === STATE.PLAYING || gameState === STATE.LANDED || gameState === STATE.CRASHED) {
        drawSpotlight(); 
        drawSub();
    }
    
    if (gameState === STATE.IMPLODED) drawImplosion();
    ctx.restore(); 
}

function drawIntro() {
    drawMarineSnow();
    
    ctx.save();
    ctx.textAlign = "center";
    ctx.fillStyle = C_BLUE; 
    ctx.font = "bold 24px Courier New";
    
    let lineHeight = 40;
    let y = introScrollY;
    
    for(let line of introLines) {
        if (y > -50 && y < height + 50) { // Optimize drawing
            ctx.fillText(line, width/2, y);
        }
        y += lineHeight;
    }
    
    // Skip hint
    ctx.font = "16px Courier New";
    ctx.fillStyle = "rgba(0, 255, 255, 0.5)";
    ctx.fillText("[PRESS ANY KEY TO SKIP]", width/2, height - 30);
    
    ctx.restore();
}

function drawMarineSnow() {
    ctx.fillStyle = 'rgba(100, 200, 200, 0.3)';
    marineSnow.forEach(p => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
        ctx.fill();
    });
}

function drawSpotlight() {
    let angle = sub.tilt + (Math.PI/2); 
    let viewDist = 300;
    let coneWidth = 150;
    let grad = ctx.createRadialGradient(sub.x, sub.y, 10, sub.x, sub.y + 100, viewDist);
    grad.addColorStop(0, 'rgba(0, 255, 255, 0.15)');
    grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
    
    ctx.save();
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.moveTo(sub.x, sub.y);
    ctx.lineTo(sub.x - coneWidth, sub.y + viewDist);
    ctx.lineTo(sub.x + coneWidth, sub.y + viewDist);
    ctx.fill();
    ctx.restore();
}

function drawTitleScreen() {
    drawMarineSnow();
    drawWaves();
    drawBubbles();
    ctx.save();
    ctx.strokeStyle = C_BLUE;
    ctx.shadowColor = C_BLUE;
    ctx.shadowBlur = 0; // Removed blur for crisp text
    ctx.lineWidth = 3;
    let cx = width / 2, cy = height / 2;
    ctx.textAlign = "center";
    ctx.font = "bold 60px Courier New";
    ctx.strokeText("ABYSSAL", cx, cy - 40);
    ctx.strokeText("LANDER", cx, cy + 30);
    ctx.font = "20px Courier New";
    ctx.lineWidth = 1;
    ctx.shadowBlur = 0;
    let t = isNaN(timeAccumulator) ? 0 : timeAccumulator;
    let alpha = (Math.sin(t * 3) + 1) / 2; 
    ctx.fillStyle = `rgba(0, 255, 255, ${alpha})`;
    let promptText = isMobileDevice() ? "TAP [INIT] TO DIVE" : "PRESS [SPACE] OR CLICK TO DIVE";
    ctx.fillText(promptText, cx, cy + 100);
    ctx.restore();
}

function drawWaves() {
    ctx.beginPath();
    ctx.strokeStyle = C_BLUE;
    ctx.lineWidth = 1;
    let t = isNaN(timeAccumulator) ? 0 : timeAccumulator;
    for (let j = 0; j < 3; j++) {
        let yOffset = 30 + j * 10;
        let amplitude = 10 - j * 2;
        let speed = 1 + j * 0.5;
        ctx.moveTo(0, yOffset);
        for (let x = 0; x < width; x += 10) {
            let y = yOffset + Math.sin(x * 0.02 + t * speed) * amplitude;
            ctx.lineTo(x, y);
        }
    }
    ctx.stroke();
}

function drawTerrain() {
    ctx.strokeStyle = C_BLUE;
    ctx.lineWidth = 2;
    ctx.shadowBlur = 0; // Removed glow for crisp lines
    ctx.beginPath();
    if (terrain.length > 0) {
        ctx.moveTo(terrain[0].x, terrain[0].y);
        for (let i = 1; i < terrain.length; i++) ctx.lineTo(terrain[i].x, terrain[i].y);
    }
    
    if (gameState === STATE.PLAYING) {
        let grad = ctx.createLinearGradient(0, 0, 0, height);
        grad.addColorStop(0, '#003333'); 
        grad.addColorStop(1, '#001111'); 
        ctx.strokeStyle = '#005555'; 
    } else {
        ctx.strokeStyle = C_BLUE;
    }
    ctx.stroke();

    if (gameState === STATE.PLAYING) {
        ctx.save();
        ctx.beginPath();
        ctx.arc(sub.x, sub.y, 250, 0, Math.PI*2);
        ctx.clip();
        
        ctx.beginPath();
        ctx.strokeStyle = C_BLUE;
        ctx.shadowColor = C_BLUE;
        ctx.shadowBlur = 0; // Removed glow here too
        if (terrain.length > 0) {
            ctx.moveTo(terrain[0].x, terrain[0].y);
            for (let i = 1; i < terrain.length; i++) ctx.lineTo(terrain[i].x, terrain[i].y);
        }
        ctx.stroke();
        ctx.restore();
    }

    ctx.strokeStyle = C_WHITE;
    ctx.lineWidth = 3;
    
    // Draw Pads
    ctx.beginPath();
    for (let i = 0; i < terrain.length - 1; i++) {
        if (terrain[i].type === 'pad' && terrain[i+1].type === 'pad') {
            ctx.moveTo(terrain[i].x, terrain[i].y);
            ctx.lineTo(terrain[i+1].x, terrain[i+1].y);
        }
    }
    ctx.stroke();

    // Draw Pad Text
    let closestDist = Infinity;
    currentNearestDepth = 0;
    
    let padStartIndex = -1;

    const processPad = (startIdx, endIdx) => {
        if (startIdx >= endIdx) return; 

        let pStart = terrain[startIdx];
        let pEnd = terrain[endIdx];
        let midX = (pStart.x + pEnd.x) / 2;
        let padY = pStart.y;
        let padDepth = Math.floor((padY - 50) / 5) + (level - 1) * 100;

        let dist = Math.abs(sub.x - midX);
        let dy = Math.abs(sub.y - padY);
        
        if (dist < 300 && dy < 300) {
            ctx.save();
            ctx.fillStyle = C_WHITE;
            ctx.font = '12px Courier New';
            ctx.textAlign = 'center';
            ctx.shadowBlur = 0; // Ensure text is crisp
            ctx.fillText(padDepth + "m", midX, padY - 15);
            ctx.restore();
        }

        if (dist < closestDist) {
            closestDist = dist;
            currentNearestDepth = padDepth;
        }
    };

    for (let i = 0; i < terrain.length; i++) {
        let isPad = terrain[i].type === 'pad';
        if (isPad) {
            if (padStartIndex === -1) padStartIndex = i; 
        } else {
            if (padStartIndex !== -1) {
                processPad(padStartIndex, i - 1);
                padStartIndex = -1;
            }
        }
    }
    if (padStartIndex !== -1) {
        processPad(padStartIndex, terrain.length - 1);
    }
}

function drawSub() {
    ctx.save();
    ctx.translate(sub.x, sub.y);
    ctx.rotate(sub.tilt); 
    
    // Explicitly kill any inherited shadow/glow
    ctx.shadowBlur = 0;
    ctx.shadowColor = 'transparent';

    if (sub.stress > 100) {
        ctx.strokeStyle = `rgb(255, ${255 - (sub.stress-100)*5}, ${255 - (sub.stress-100)*5})`;
        ctx.lineWidth = 2 + Math.random() * 2; 
    } else {
        ctx.strokeStyle = C_WHITE;
        ctx.lineWidth = 2;
    }
    const w = sub.width; const h = sub.height; 
    ctx.beginPath(); ctx.rect(-w/2, -h/2, w, h); ctx.stroke();
    ctx.beginPath(); ctx.arc(-w/2, 0, h/2, 0.5 * Math.PI, 1.5 * Math.PI); ctx.stroke();
    ctx.beginPath(); ctx.arc(w/2, 0, h/2, 1.5 * Math.PI, 0.5 * Math.PI); ctx.stroke();
    ctx.beginPath(); ctx.arc(w/2 + 2, 0, 3, 0, Math.PI * 2); ctx.stroke();
    ctx.lineWidth = 1.5;
    const skidY = h/2 + 5; const skidW = w * 0.6;
    ctx.beginPath(); ctx.moveTo(skidW/2, h/2); ctx.lineTo(skidW/2, skidY); ctx.lineTo(skidW/2 + 5, skidY); 
    ctx.moveTo(-skidW/2, h/2); ctx.lineTo(-skidW/2, skidY); ctx.lineTo(-skidW/2 - 5, skidY); 
    ctx.moveTo(-skidW/2, skidY); ctx.lineTo(skidW/2, skidY); ctx.stroke();
    ctx.lineWidth = 1;
    ctx.beginPath(); ctx.rect(-w/2 - 4, -h/2 - 4, 8, 4); ctx.rect(-w/2 - 4, h/2, 8, 4); ctx.stroke();
    ctx.restore();
}

function drawBubbles() {
    ctx.strokeStyle = 'rgba(0, 255, 255, 0.5)';
    ctx.lineWidth = 1;
    ctx.beginPath();
    bubbles.forEach(b => {
        ctx.moveTo(b.x, b.y); ctx.lineTo(b.x - b.vx * 0.1, b.y - b.vy * 0.1); 
    });
    ctx.stroke();
}

function drawParticles() {
    ctx.strokeStyle = C_WHITE;
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    particles.forEach(p => {
        let dx = Math.cos(p.angle) * p.len;
        let dy = Math.sin(p.angle) * p.len;
        ctx.moveTo(p.x, p.y); ctx.lineTo(p.x + dx, p.y + dy);
    });
    ctx.stroke();
}

function drawImplosion() {}

function spawnBubbles(dir) {
    let count = 2; let bx, by, angle, spread;
    if (dir === 'ambient') {
        if (Math.random() > 0.1) return; 
        bx = Math.random() * width; by = height; angle = -Math.PI/2; spread = 0.2; count = 1;
    } else if (dir === 'vertical_down') {
        bx = sub.x; by = sub.y + sub.height/2 + 5; angle = Math.PI / 2; spread = 0.5;
    } else if (dir === 'vertical_up') {
        bx = sub.x; by = sub.y - sub.height/2 - 5; angle = -Math.PI / 2; spread = 0.5;
    } else if (dir === 'left') {
        bx = sub.x - sub.width/2 - 5; by = sub.y; angle = Math.PI; spread = 0.5;
    } else if (dir === 'right') {
        bx = sub.x + sub.width/2 + 5; by = sub.y; angle = 0; spread = 0.5;
    }
    for(let i=0; i<count; i++) {
        bubbles.push({
            x: bx + (Math.random()-0.5)*10, y: by + (Math.random()-0.5)*5,
            vx: Math.cos(angle + (Math.random()-0.5)*spread) * (dir === 'ambient' ? 20 : 40),
            vy: Math.sin(angle + (Math.random()-0.5)*spread) * (dir === 'ambient' ? 20 : 40),
            life: dir === 'ambient' ? 5.0 : 0.8
        });
    }
}

function updateBubbles(dt) {
    for (let i = bubbles.length - 1; i >= 0; i--) {
        let b = bubbles[i];
        b.x += b.vx * dt; b.y += b.vy * dt; b.life -= dt * 2; 
        if (b.life <= 0) bubbles.splice(i, 1);
    }
}

function updateParticles(dt) {
    particles.forEach(p => {
        p.life++;
        if (p.phase === 'implode') {
            let dx = p.targetX - p.x; let dy = p.targetY - p.y; let dist = Math.sqrt(dx*dx + dy*dy);
            if (dist < 5 || p.life > 8) {
                p.phase = 'drift'; p.vx = (Math.random() - 0.5) * 20; p.vy = (Math.random() - 0.5) * 20;
            } else { p.x += dx * 0.3; p.y += dy * 0.3; }
        } else {
            p.vx *= 0.95; p.vy *= 0.95; p.vy += 5 * dt; p.x += p.vx; p.y += p.vy;
        }
    });
}

function getSubPolygon() {
    // Tweak hitbox to be slightly more forgiving at the bottom (skids)
    // and tighter at the top to avoid phantom ceiling clips
    const w = sub.width / 2 + 4; // reduced from +6
    const h = sub.height / 2 + 5; 
    const angle = sub.tilt; 
    const cos = Math.cos(angle); const sin = Math.sin(angle);
    const corners = [{x: -w, y: -h}, {x: w, y: -h}, {x: w, y: h}, {x: -w, y: h}];
    return corners.map(p => ({ x: sub.x + (p.x * cos - p.y * sin), y: sub.y + (p.x * sin + p.y * cos) }));
}

function lineIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
    const denom = (y4 - y3) * (x2 - x1) - (x4 - x3) * (y2 - y1);
    if (denom === 0) return false;
    const ua = ((x4 - x3) * (y1 - y3) - (y4 - y3) * (x1 - x3)) / denom;
    const ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / denom;
    return (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1);
}

function updateUI() {
    if (gameState === STATE.INTRO || gameState === STATE.TITLE) { uiElements.style.display = 'none'; return; }
    uiElements.style.display = 'block';
    
    let rawDepth = Math.floor((sub.y - 50) / 5);
    let levelOffset = (level - 1) * 100;
    uiDepth.innerText = rawDepth + levelOffset;
    uiTargetDepth.innerText = currentNearestDepth || "--";
    uiLevel.innerText = level;

    // UPDATE V.SPEED DISPLAY with DYNAMIC LIMIT
    let vDisplay = (-sub.vy * 5).toFixed(1); 
    uiVSpeed.innerText = vDisplay;
    
    let vSpeedVal = Math.abs(sub.vy * 10);
    uiVSpeed.style.color = vSpeedVal > currentSafeLandingSpeed ? C_RED : C_BLUE;

    // UPDATE H.SPEED DISPLAY
    let hDisplay = (Math.abs(sub.vx) * 5).toFixed(1);
    uiHSpeed.innerText = hDisplay;
    // Color Logic for H.Speed: Limit is 5 (internal)
    let hSpeedVal = Math.abs(sub.vx * 10);
    uiHSpeed.style.color = hSpeedVal >= 5 ? C_RED : C_BLUE;

    uiFuel.innerText = Math.floor(sub.fuel);
    uiHull.innerText = Math.floor(sub.hull);
    uiScore.innerText = score;

    uiHullRow.className = sub.hull < 30 ? 'hud-line warning' : 'hud-line';
    uiFuel.style.color = sub.fuel < 20 ? C_RED : C_BLUE;

    let stressPct = Math.min(100, (sub.stress / MAX_STRESS) * 100);
    uiStressBar.style.width = stressPct + "%";
    if (sub.stress > 100) {
        uiStressBar.style.backgroundColor = C_RED;
        uiStressBar.style.boxShadow = `0 0 10px ${C_RED}`;
        uiStressText.innerText = "CRITICAL OVERLOAD";
        uiStressText.classList.add("warning");
    } else if (sub.stress > 80) {
        uiStressBar.style.backgroundColor = C_WARN;
        uiStressBar.style.boxShadow = `0 0 5px ${C_WARN}`;
        uiStressText.innerText = "PRESSURE CRITICAL";
        uiStressText.classList.remove("warning");
    } else {
        uiStressBar.style.backgroundColor = C_BLUE;
        uiStressBar.style.boxShadow = `0 0 5px ${C_BLUE}`;
        uiStressText.innerText = "PRESSURE STABLE";
        uiStressText.classList.remove("warning");
    }
}

function loop(timestamp) {
    try {
        if (!lastTime) lastTime = timestamp; 
        const dt = (timestamp - lastTime) / 1000;
        lastTime = timestamp;
        
        frameCount++;
        if (!isNaN(dt) && dt < 0.2) {
            update(dt);
        }
        
        draw();
        requestAnimationFrame(loop);
    } catch(e) {
        console.error("[ABYSSAL] GAME CRASH:", e);
        ctx.fillStyle = 'red';
        ctx.font = '30px Courier New';
        ctx.fillText("CRITICAL ERROR - CHECK CONSOLE", 50, 300);
    }
}

requestAnimationFrame(loop);

</script>
</body>
</html>